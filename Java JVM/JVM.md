# Java JVM

## 1. 运行时数据区

Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域。

#### 主要知识点：

* 运行时数据区的**组成**（JDK 1.6，JDK 1.7，JDK 1.8的区别）

* 每个区域的**详解**

##### JVM内存区域组成：

* $\leq$1.6 ： 程序计数器，虚拟机栈，本地方法栈，堆，方法区（其中包含运行时常量池，字符串常量池）

* 1.7 ： 程序计数器，虚拟机栈，本地方法栈，堆（其中包含运行时常量池，字符串常量池），方法区

* $\geq$1.8 ： 程序计数器，虚拟机栈，本地方法栈，堆（其中包含运行时常量池，字符串常量池），元空间

##### 变化：

1.6 vs 1.7：运行时常量池，字符串常量池从方法区移到堆，并且，加载的类信息...等被转移到 堆 里面的运行时常量池中了

1.7 vs 1.8 ：方法区从运行时数据区移到直接内存，元空间替代永久代

##### JDK 1.6

##### 具体介绍：

* **虚拟机栈 (JVM Stacks)**

  > 线程私有
  >
  > 存放：是由一个个栈帧组成，而每个栈帧中都拥有：**局部变量表**（八种基本数据类型变量，部分的返回结果，非基本类型对象指向堆上的地址）**、操作数栈、动态链接、方法出口信息**。
  >
  > 不需要进行 GC。

* **本地方法栈(Native Method Stacks)**

  > 线程私有
  >
  > 存放：**每个native方法调用的状态**
  >
  > 为虚拟机执行本地方法时服务的
  >
  > 不需要进行 GC

* **程序计数器**

  > 线程私有
  >
  > 存放：每个线程**下一步将执行的JVM指令**, 如该方法为native的，则PC寄存器中不存储任何信息。
  >
  > 字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。
  >
  > 记录当前线程的位置便于线程切换与恢复；
  >
  > **程序计数器是唯一一个不会出现     OutOfMemoryError （OOM）的内存区域**，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。

* **堆 (Heap)**

  > 线程共享
  >
  > 存放：**对象实例和数组**
  >
  > Java 堆是垃圾收集器管理的主要区域，因此也被称作GC     堆。从垃圾回收的角度， Java 堆还可以细分为：新生代和老年代。

* **1.7 的方法区 (Method Area)**

  > - 线程共享
  > - **存放：**被虚拟机加载的类信息(名称、修饰符等)、类中的静态变量、 类中定义为final类型的常量、类中的Field信息、类中的方法信息
  > - 方法区只是一个概念，永久代或者元空间是它的实现

*  **运行时常量池(Runtime Constant Pool)**

  > 存放：类中的固定的常量信息、方法和Field的引用信息等。编译期间生成的字面量、符号引用

*  **元空间** **(MetaSpace)**

  >在直接内存中
  >
  >存放：类的**元数据**。如方法、字段、类、包的描述信息，这些信息可以用于创建文档、跟踪代码中的依赖性、执行编译时检查
  >
  >方法区里面的那些东西，大部分都被移到堆里面去了，还剩下一些元数据被保存在元空间里面
  >
  >元空间有单独的元空间虚拟机执行内存分配与垃圾回收

**为什么用元空间替换永久代？**

1. **内存溢出的几率变小：**永久代有固定大小上限。元空间的大小是受本机可用内存的限制，内存溢出的概率会更小。
2. **提升GC性能：**永久代的 GC 特别难搞，严重影响 Full GC 的性能。于是抛弃永久代，使用元空间，从而让     Full GC 不再关心方法区
3. **增加可操作空间：**元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 MaxPermSize 控制了, 而由系统的实际可用空间来控制，这样能加载的类就更多了。



